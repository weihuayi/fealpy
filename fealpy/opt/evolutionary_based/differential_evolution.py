from abc import ABC, abstractmethod

from ...backend import backend_manager as bm
from ..optimizer_base import Optimizer

class MutationStrategy(ABC):
    """
    Abstract base class for mutation strategies in Differential Evolution (DE) algorithms.
    
    Defines the interface that all mutation strategies must implement. 
    Responsible for generating trial vectors during the mutation phase.
    
    Attributes:
        de (DifferentialEvolution): The associated DE algorithm instance.
    """
    def __init__(self, de_algorithm):
        """
        Initialize the mutation strategy.
        
        Args:
            de_algorithm (DifferentialEvolution): The DE algorithm instance.
        """
        self.de = de_algorithm 
        
    @abstractmethod
    def mutate(self):
        """
        Perform the mutation operation to generate trial vectors.
        
        Returns:
            ndarray: Array of trial vectors generated by the mutation strategy.
        """
        pass

class MutationRegistry:
    """
    Registry for mutation strategies. Manages and creates instances of registered strategies.
    
    Attributes:
        strategies (dict): Mapping of registered strategy names to their respective classes.
    """
    strategies = {}
    
    @classmethod
    def register(cls, name):
        """
        Decorator to register a mutation strategy class.
        
        Args:
            name (str): Name of the mutation strategy.
            
        Returns:
            function: Decorator function that registers the class.
        """
        def decorator(subclass):
            if not issubclass(subclass, MutationStrategy):
                raise ValueError("Must inherit from MutationStrategy")
            cls.strategies[name] = subclass
            return subclass
        return decorator
    
    @classmethod
    def create(cls, name, de_algorithm):
        """
        Create an instance of a registered mutation strategy.
        
        Args:
            name (str): Name of the registered strategy.
            de_algorithm (DifferentialEvolution): DE algorithm instance.
            
        Returns:
            MutationStrategy: Instance of the specified mutation strategy.
            
        Raises:
            ValueError: If the strategy name is not registered.
        """
        if name not in cls.strategies:
            raise ValueError(f"Mutation strategy {name} is not registered")
        return cls.strategies[name](de_algorithm)

@MutationRegistry.register("rand/1")
class RandOneMutation(MutationStrategy):
    """
    Implementation of the rand/1 mutation strategy.
    
    Generates trial vectors by the formula: v = x1 + F*(x2-x3)
    where x1, x2, x3 are randomly selected distinct individuals from the population.
    """
    def mutate(self):
        """
        Perform rand/1 mutation.
        
        Returns:
            ndarray: Array of trial vectors generated using random individuals.
        """
        
        # Randomly select three distinct individuals
        v = self.de.x[bm.random.randint(0, self.de.N, (self.de.N,))] + self.de.f * (
                self.de.x[bm.random.randint(0, self.de.N, (self.de.N,))] - 
                self.de.x[bm.random.randint(0, self.de.N, (self.de.N,))]
            ) 
        return v
    
@MutationRegistry.register("best/1")
class BestOneMutation(MutationStrategy):
    """
    Implementation of the best/1 mutation strategy.
    
    Generates trial vectors using the current best individual: v = best + F*(x1-x2)
    where best is the current global best solution, and x1, x2 are random individuals.
    """
    def mutate(self):
        """
        Perform best/1 mutation.
        
        Returns:
            ndarray: Array of trial vectors generated using the best individual.
        """
        # Mutation based on the best solution
        v = self.de.gbest + self.de.f * (
            self.de.x[bm.random.randint(0, self.de.N, (self.de.N,))] - 
            self.de.x[bm.random.randint(0, self.de.N, (self.de.N,))]
        )
        return v
    
@MutationRegistry.register("current-to-best/1")
class CurrentToBestOne(MutationStrategy):
    """
    Implementation of the "current-to-best/1" mutation strategy.
    
    This strategy combines the current individual, the global best individual, 
    and two random individuals to generate trial vectors, balancing exploitation 
    and exploration in the search space.
    """
    def mutate(self):
        """
        Perform the "current-to-best/1" mutation operation.
        
        Returns:
            ndarray: Array of trial vectors generated by the mutation strategy.
            The formula for generating trial vectors is:
            v = x + F * (gbest - x) + F * (x[r1] - x[r2])
            where:
            - x is the current population,
            - gbest is the global best individual,
            - x[r1] and x[r2] are two randomly selected distinct individuals from the population,
            - F is the mutation factor (scaling factor).
            
        Notes:
            This strategy directs the search towards the global best solution while 
            maintaining diversity through random perturbations. The use of the current 
            individual helps preserve some of the existing information, leading to 
            a more stable convergence.
        """
        v = (
            self.de.x + self.de.f * (self.de.gbest - self.de.x) + self.de.f * (
                self.de.x[bm.random.randint(0, self.de.N, (self.de.N,))] - 
                self.de.x[bm.random.randint(0, self.de.N, (self.de.N,))]
            )
        )
        return v

class DifferentialEvolution(Optimizer):
    """
    A differential evolution (DE) optimization algorithm, inheriting from the Optimizer class.

    This class implements the differential evolution algorithm, a population-based optimization method 
    commonly used for global optimization problems. It initializes with a set of options and iteratively 
    improves the solution through mutation, crossover, and selection operations.

    Parameters:
        option: Configuration options for the optimizer, typically including parameters like population size, 
                maximum iterations, and bounds for the search space.

    Attributes:
        gbest (array): The best solution found during the optimization process.
        gbest_f (float): The fitness value of the best solution.
        curve (array): An array storing the best fitness value at each iteration.

    Methods:
        run(F=0.2, CR=0.5): Executes the differential evolution algorithm.
            Parameters:
                F (float): The mutation factor, controlling the amplification of the differential variation.
                CR (float): The crossover probability, determining the likelihood of crossover between solutions.
    """
    def __init__(self, option) -> None:
        """
        Initializes the DifferentialEvolution optimizer with the given options.

        Parameters:
            option: Configuration options for the optimizer.
        """
        super().__init__(option)

    def run(self, params={'f':0.2, 'cr':0.5}, mutation_strategy="rand/1"):
        """
        Runs the differential evolution algorithm.

        Parameters:
            F (float): The mutation factor, default is 0.2.
            CR (float): The crossover probability, default is 0.5.
        """

        strategy = MutationRegistry.create(mutation_strategy, self)

        # Initialize fitness values and find the best solution in the initial population
        self.f = params.get('f')
        cr = params.get('cr')
        fit = self.fun(self.x)
        gbest_index = bm.argmin(fit)
        self.gbest = self.x[gbest_index]
        self.gbest_f = fit[gbest_index]

        # Iterate through the maximum number of iterations
        for it in range(0, self.MaxIT):
            self.D_pl_pt(it)

            # Mutation: Generate a mutant vector based on random individuals
            v = strategy.mutate()

            # Crossover: Combine the mutant vector with the current population
            mask = bm.random.rand(self.N, self.dim) < cr
            x_new = bm.where(mask, v, self.x)

            # Boundary handling: Ensure the new solutions stay within the bounds
            x_new = x_new + (self.lb - x_new) * (x_new < self.lb) + (self.ub - x_new) * (x_new > self.ub)

            # Evaluation: Calculate the fitness of the new solutions
            fit_new = self.fun(x_new)

            # Selection: Replace the current population with better solutions
            mask = fit_new < fit
            self.x, fit = bm.where(mask[:, None], x_new, self.x), bm.where(mask, fit_new, fit)
            self.update_gbest(self.x, fit)

            # Record the best fitness value at the current iteration
            self.curve[it] = self.gbest_f