from typing import Literal, Any
from dataclasses import dataclass, field
from enum import IntEnum, auto

from fealpy.cgraph.core import CNode


class DataType(IntEnum):
    NONE     = 0
    MESH     = auto()
    BOOL     = auto()
    INT      = auto()
    FLOAT    = auto()
    TENSOR   = auto()
    LINOPS   = auto()
    STRING   = auto()
    MENU     = auto()
    SPACE    = auto()
    DOMAIN   = auto()
    FUNCTION = auto()


@dataclass(slots=True)
class PortConf:
    name    : str
    dtype   : DataType         = DataType.NONE
    """Enum of data type required"""
    ttype   : Literal[0, 1, 2] = 1
    """Enum of topology of connection
      - 0: No connection to upstream node
      - 1: Connection to single upstream node
      - 2: Connection to multiple upstream nodes (variable)
    """
    desc    : str              = ""
    """Tooltip for input/output slot"""
    title   : str | None       = None
    """Display title for input/output slot"""
    param   : str | None       = None
    default : Any              = field(default=None, kw_only=True)
    min_val : int | None       = field(default=None, kw_only=True)
    max_val : int | None       = field(default=None, kw_only=True)
    max_len : int | None       = field(default=None, kw_only=True)
    items   : list[str] | None = field(default_factory=list, kw_only=True)

    def __post_init__(self) -> None:
        if self.param is None:
            self.param = self.name
        if self.title is None:
            self.title = self.name
        if self.desc == "":
            self.desc = self.title


class CNodeType:
    TITLE: str
    PATH: str = ""
    DESC: str = ""
    INPUT_SLOTS: list[PortConf] = []
    OUTPUT_SLOTS: list[PortConf] = []
    VARIABLE: bool = False

    REGISTRY: dict[str, type["CNodeType"]] = {}

    def __init_subclass__(cls):
        super().__init_subclass__()
        if cls.__name__ not in cls.REGISTRY:
            cls.REGISTRY[cls.__name__] = cls
        else:
            raise ValueError(f"CNodeType {cls.__name__} already exists")

    def __new__(cls) -> CNode:
        node = CNode(getattr(cls, "run"), cls.VARIABLE)
        setattr(node, "__node_type__", cls.__name__)

        for data in cls.INPUT_SLOTS:
            node.register_input(
                name=data.name,
                variable=data.ttype == 2,
                parameter=data.param,
                default=data.default
            )

        for data in cls.OUTPUT_SLOTS:
            node.register_output(name=data.name)

        return node


def search(name: str, /):
    """Search and return a subclass of CNodeType by class name.
    Return None if not found.

    Parameters:
        name(str): Class name of CNodeType.

    Returns:
        CNodeType: The subclass of CNodeType.
    """
    if name in CNodeType.REGISTRY:
        return CNodeType.REGISTRY[name]
    else:
        return None


def create(name: str, /):
    """Create a Node instance from a nodetype name.

    Parameters:
        name(str): Class name of CNodeType.

    Returns:
        Node: The Node instance.
    """
    if name in CNodeType.REGISTRY:
        return CNodeType.REGISTRY[name]()
    else:
        raise ValueError(f"CNodeType {name} not found")


def from_dict(node_data: dict[str, Any]):
    assert isinstance(node_data, dict), "data of each node must be a dict"
    name = node_data.get("name", None)
    node = create(name)

    if "val" in node_data:
        node(**node_data["val"])

    return node


def to_dict(node: CNode):
    if hasattr(node, "__node_type__"):
        name = node.__node_type__
    else:
        raise ValueError("Can not find node type. "
                            "Maybe the node is not generated by CNodeType.")
    return {
        "name": name,
        "val": {
            inslot: val.default for inslot, val in node.input_slots.items()
            if val.has_default
        }
    }
